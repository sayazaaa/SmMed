/**
 * SmMed
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include <QJsonArray>
#include <QJsonDocument>
#include <QJsonObject>
#include <QVariantMap>
#include <QDebug>

#include "DefaultApiHandler.h"
#include "DefaultApiRequest.h"
#include "global.h"
namespace HttpServer {

DefaultApiHandler::DefaultApiHandler(){

}

DefaultApiHandler::~DefaultApiHandler(){

}

void DefaultApiHandler::loginPost(QString id, QString password, bool usertype, QString apikey, Object body) {
    auto reqObj = qobject_cast<DefaultApiRequest*>(sender());
    if(id == "root" && apikey =="429080af-532a-48a0-868b-42159fd4319e"){
        apiVerifyMap[apikey] = {id,"root"};
        QJsonObject obj;
        obj.insert("apikey",apikey);
        QJsonDocument doc(obj);
        reqObj->loginPostResponse(Inline_response_200(doc.toJson()));
        qDebug() << "send succeed";
        return;
    }
    Q_UNUSED(body);
    qDebug() << "default api handler login post:" << usertype;

    if( reqObj != nullptr )
    {
        QSharedPointer<QJsonDocument> jsondoc;
        Inline_response_200 res;
        try {
            if(id == "root"){
                throw std::exception();
            }
            jsondoc = usertype?dbserver->verify_userpassword(id,password):dbserver->verify_doctorpassword(id,password);
        } catch (std::exception e) {
            QString error_str = "login failed!";
            reqObj->loginPostError(res,QNetworkReply::NetworkError::UnknownNetworkError,error_str);
            return;
        }
        qDebug() << "going to send result...";
        //res.fromJson(jsondoc->toJson());
        res = Inline_response_200(jsondoc->toJson());
        reqObj->loginPostResponse(res);
        qDebug() << "send succeed";
    }
}
void DefaultApiHandler::sqlGet(QString sql, QString apikey, QString id, bool usertype) {
    Q_UNUSED(usertype)
    qDebug() << "get sql query!" << endl << sql;
    auto reqObj = qobject_cast<DefaultApiRequest*>(sender());
    QSharedPointer<QJsonDocument> resjson;
    try {
        if(apiVerifyMap[apikey].first != id){
            qDebug() << apiVerifyMap[apikey].first << ":" << id;
            std::exception e;
            throw e;
        }
        std::string sqlstd = sql.toStdString();
        qDebug() << "going to sqlquery:" << sql;
        dbserver->sqlquery(&sqlstd,resjson);
        std::string s = sqlstd.substr(0,6);
        for(size_t i = 0; i < s.length();i++)s[i] = toupper(s[i]);
        if(s != "SELECT"){
            QJsonObject obj = resjson->object();
            if(!obj["id"].toString().size()){
                obj["id"] = id;
            }
            resjson = QSharedPointer<QJsonDocument>(new QJsonDocument(obj));
        }
    } catch (std::exception e) {
        if(reqObj != nullptr){
            Object res;
            QString error_str = "SQL ERROR!";
            reqObj->sqlGetError(res,QNetworkReply::NetworkError::UnknownNetworkError,error_str);
        }

        return;
    }

    if( reqObj != nullptr )
    {
        qDebug() << "going to send result...";
        qDebug() << (*resjson);
        reqObj->sqlGetResponse(*resjson);
        qDebug() << "send succeed!";
    }
}


}
